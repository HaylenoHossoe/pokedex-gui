# .github/workflows/ci-cd.yml

name: Pokédex Gui - CI/CD completo com SonarQubeCloud 

on:
  push:
    branches:
      - containers-ecs # Certifique-se de que esta é a branch que você está usando
  workflow_dispatch: {} # Permite execução manual

permissions:
  contents: read # Permite ler o código do repositório
  id-token: write # Adicionar esta permissão para SonarCloud

jobs:
  # Job 1: Integração Contínua (Teste e Build)
  test_and_build:
    runs-on: ubuntu-latest

    steps:
      - name: Verifica o código
        uses: actions/checkout@v2
        with:
          # Fetch all history for SonarQube analysis
          fetch-depth: 0 

      - name: Instala dependências
        run: npm install

      # aqui ficava o workflou do SonarQube, movido para outro arquivo

      - name: Executa testes
        run: npm run test

      - name: Build React App (para validação do build antes do Docker)
        run: npm run build
        env:
          CI: false # Desabilita o erro de "warnings as errors"

  # Job 2: Implantação Contínua (Deploy)
  deploy:
    runs-on: ubuntu-latest
    environment: production
    needs: test_and_build # Este job só roda se "test_and_build" for bem-sucedido

    steps:
      - name: Verifica o código
        uses: actions/checkout@v2

      - name: Configure AWS Credentials for Academy
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      # --- PASSO CRUCIAL: DEPLOY DA INFRA DO ECS/FARGATE (Deve vir PRIMEIRO para criar o ECR) ---
      # Este passo criará/atualizará o ECR (se ainda não existir), o Cluster,
      # a Task Definition e o Serviço ECS.
      - name: Deploy ECS/Fargate CloudFormation Stack
        run: |
          set -x # Mantenha isso para depuração adicional
          aws cloudformation deploy \
            --template-file cloudformation-ecs.yml \
            --stack-name PokedexGuiEcsStack \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              VpcId=vpc-0ef104b9a906559fd \
              SubnetIds=subnet-0fc5a99dc1a158475,subnet-096e1bc5f6623b31f
      # --- FIM DEPLOY INFRA ---

      # --- MÓDULO 4.1: LOGIN NO ECR (Agora o repositório ECR DEVE existir) ---
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      # --- FIM MÓDULO 4.1 ---

      # --- MÓDULO 4.2 (Parte 1): BUILD DA IMAGEM DOCKER ---
      - name: Build Docker Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: pokedex-gui-frontend-repo # Nome do repositório ECR
          IMAGE_TAG: latest # Usamos 'latest' para simplicidade, conforme sua Task Definition
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
      # --- FIM MÓDULO 4.2 (Parte 1) ---

      # Trivy Scan (comentado)

      # --- MÓDULO 4.2 (Parte 2): PUSH DA IMAGEM DOCKER PARA ECR ---
      - name: Push Image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: pokedex-gui-frontend-repo
          IMAGE_TAG: latest
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      # --- FIM MÓDULO 4.2 (Parte 2) ---

      # --- MÓDULO 4.3: ATUALIZAR O SERVIÇO ECS (Opcional, mas útil para forçar nova implantação) ---
      # Este passo é para garantir que o ECS force uma nova implantação,
      # mesmo que a definição da tarefa não tenha mudado, apenas a imagem "latest".
      - name: Force new ECS service deployment
        run: |
          aws ecs update-service \
            --cluster PokedexGui-Cluster \
            --service PokedexGui-Frontend-Service \
            --force-new-deployment