# .github/workflows/ci-cd.yml

name: Pokédex Gui - CI/CD Completo com sonarcloud

on:
  push:
    branches:
      - containers-ecs # Certifique-se de que esta é a branch que você está usando
  workflow_dispatch: {} # Permite execução manual

permissions:
  contents: read # Permite ler o código do repositório
  id-token: write # Adicionar esta permissão para SonarCloud

jobs:
  # Job 1: Integração Contínua (Teste e Build)
  test_and_build:
    runs-on: ubuntu-latest

    steps:
      - name: Verifica o código
        uses: actions/checkout@v2
        with:
          # Fetch all history for SonarQube analysis
          fetch-depth: 0 

      - name: Instala dependências
        run: npm install

#     # --- INÍCIO: INTEGRAÇÃO SONARQUBE CLOUD (Comentado, mas pode ser ativado se necessário) ---
#     - name: Set up Node.js
#       uses: actions/setup-node@v3
#       with:
#         node-version: '18' # Verifique a compatibilidade com seu projeto React

#     - name: Run SonarQube Analysis
#       uses: SonarSource/sonarcloud-github-action@v2.2 # AÇÃO OFICIAL PARA SONARCLOUD
#       env:
#         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Necessário para a action interagir com o GitHub
#         SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}   # Seu token pessoal do SonarCloud
#       with:
#         projectKey: HaylenoHossoe_pokedex-gui # SEU PROJECT KEY DO SONARCLOUD (CORRETO!)
#         # organization: sua-organizacao-no-sonarcloud # Descomente e preencha se tiver uma organização
#     # --- FIM: INTEGRAÇÃO SONARQUBE CLOUD ---

      - name: Executa testes
        run: npm run test

      - name: Build React App (para validação do build antes do Docker)
        run: npm run build
        env:
          CI: false # Desabilita o erro de "warnings as errors"

  # Job 2: Implantação Contínua (Deploy)
  deploy:
    runs-on: ubuntu-latest
    environment: production
    needs: test_and_build # Este job só roda se "test_and_build" for bem-sucedido

    steps:
      - name: Verifica o código
        uses: actions/checkout@v2

      - name: Configure AWS Credentials for Academy
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      # --- MÓDULO 4.1: LOGIN NO ECR ---
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      # --- FIM MÓDULO 4.1 ---

      # --- MÓDULO 4.2 (Parte 1): BUILD DA IMAGEM DOCKER ---
      - name: Build Docker Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: pokedex-gui-frontend-repo # Nome do repositório ECR
          IMAGE_TAG: latest # Usamos 'latest' para simplicidade, conforme sua Task Definition
        run: |
           docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
      # --- FIM MÓDULO 4.2 (Parte 1) ---

#      # --- MÓDULO 5.1: SCAN DE VULNERABILIDADES COM TRIVY ---
#      - name: Scan Docker Image with Trivy
#        uses: aquasecurity/trivy-action@master # Use a versão mais recente
#        with:
#          image-ref: ${{ steps.login-ecr.outputs.registry }}/pokedex-gui-frontend-repo:latest
#          format: 'table'
#          exit-code: '1' # Falha o pipeline se encontrar vulnerabilidades
#          ignore-unfixed: true # Ignora vulnerabilidades que não possuem fix disponível
#          severity: 'CRITICAL,HIGH' # Apenas reporte e falhe para CRITICAL e HIGH
#      # --- FIM MÓDULO 5.1 ---

      # --- MÓDULO 4.2 (Parte 2): PUSH DA IMAGEM DOCKER PARA ECR ---
      - name: Push Image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: pokedex-gui-frontend-repo
          IMAGE_TAG: latest
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      # --- FIM MÓDULO 4.2 (Parte 2) ---

      # --- AGORA DEPLOY DA INFRA DO ECS/FARGATE (APÓS O PUSH DA IMAGEM) ---
      # Este passo criará/atualizará o ECR (se ainda não existir), o Cluster,
      # a Task Definition e o Serviço ECS. Quando o serviço ECS tentar subir as tarefas,
      # a imagem JÁ ESTARÁ no ECR.
      - name: Deploy ECS/Fargate CloudFormation Stack
        run: |
          aws cloudformation deploy \
            --template-file cloudformation-ecs.yml \
            --stack-name PokedexGuiEcsStack \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              VpcId=vpc-0ef104b9a906559fd \
              SubnetIds=subnet-0fc5a99dc1a158475,subnet-096e1bc5f6623b31f
      # --- FIM DEPLOY ---

      # --- MÓDULO 4.3: ATUALIZAR O SERVIÇO ECS (Opcional, mas útil para forçar nova implantação) ---
      # Este passo é para garantir que o ECS force uma nova implantação,
      # mesmo que a definição da tarefa não tenha mudado, apenas a imagem "latest".
      # É especialmente útil para atualizações de código que não alteram o Task Definition.
      - name: Force new ECS service deployment
        run: |
          aws ecs update-service \
            --cluster PokedexGui-Cluster \
            --service PokedexGui-Frontend-Service \
            --force-new-deployment